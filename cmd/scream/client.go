package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"os"
	"sync"
	"time"

	"fyne.io/fyne/v2"
	pb "github.com/rexlx/squall/proto"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/metadata"
)

const (
	MaxHistorySize    = 20
	MaxSavedRoomsSize = 20
)

type PendingFile struct {
	Data      []byte
	FileName  string
	Timestamp time.Time
}

type APIClient struct {
	GrpcClient pb.ChatServiceClient
	Conn       *grpc.ClientConn

	// Map of RoomID -> Stream
	Streams map[string]pb.ChatService_StreamClient
	// Map of RoomID -> CancelFunc (to stop the receiving goroutine/context)
	Cancels map[string]context.CancelFunc
	mu      sync.RWMutex

	Token   string
	User    *pb.User
	MsgChan chan *pb.ChatMessage

	// Security: Tracks files we have offered for P2P transfer
	ActiveOffers sync.Map // Map[string]PendingFile (Key: FileHash)

	// Local history tracking and UI refresh callbacks
	HistoryMu       sync.RWMutex
	LocalHistory    []string // Rooms visited in this session
	OnHistoryUpdate func()   // Callback when history changes
	OnRoomsUpdate   func()   // Callback when saved rooms change

	// Saved rooms tracking (separate from User.Rooms which may contain visited rooms from server)
	SavedRoomsMu sync.RWMutex
	SavedRooms   []string
}

var Client = &APIClient{
	MsgChan: make(chan *pb.ChatMessage, 100),
	Streams: make(map[string]pb.ChatService_StreamClient),
	Cancels: make(map[string]context.CancelFunc),
}

func LoadTLSConfig() (*tls.Config, error) {
	// Use the bundled resources generated by 'fyne bundle'
	// resourceClientCertPem and resourceClientKeyPem are defined in bundle.go
	cert, err := tls.X509KeyPair(resourceClientCertPem.Content(), resourceClientKeyPem.Content())
	if err != nil {
		return nil, err
	}

	cfh := &tls.Config{
		Certificates:       []tls.Certificate{cert},
		InsecureSkipVerify: true,
	}
	return cfh, nil
}

func InitClient() error {
	tlsConfig, err := LoadTLSConfig()
	if err != nil {
		return err
	}

	creds := credentials.NewTLS(tlsConfig)
	conn, err := grpc.Dial("localhost:8080", grpc.WithTransportCredentials(creds))
	if err != nil {
		return err
	}

	Client.Conn = conn
	Client.GrpcClient = pb.NewChatServiceClient(conn)
	return nil
}

func (c *APIClient) Login(email, password string) error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()

	resp, err := c.GrpcClient.Login(ctx, &pb.LoginRequest{
		Email:    email,
		Password: password,
	})
	if err != nil {
		return err
	}

	if resp.Error {
		return fmt.Errorf("login failed: %s", resp.Message)
	}

	c.User = resp.User
	c.Token = resp.Token

	// Initialize SavedRooms from User.Rooms
	c.SavedRoomsMu.Lock()
	c.SavedRooms = append([]string{}, c.User.Rooms...)
	c.SavedRoomsMu.Unlock()

	return nil
}

func (c *APIClient) getAuthContext(ctx context.Context) context.Context {
	md := metadata.Pairs("authorization", c.Token)
	return metadata.NewOutgoingContext(ctx, md)
}

func (c *APIClient) JoinRoom(roomName string) error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()
	ctx = c.getAuthContext(ctx)

	resp, err := c.GrpcClient.JoinRoom(ctx, &pb.JoinRoomRequest{
		Email:    c.User.Email,
		RoomName: roomName,
	})
	if err != nil {
		return err
	}

	if len(resp.History) > 0 {
		for _, msg := range resp.History {
			c.MsgChan <- msg
		}
	}

	// Update local history when joining a room
	c.AddToLocalHistory(roomName)
	return c.StartStream(roomName)
}

func (c *APIClient) AddRoomToCache(roomName string) {
	c.SavedRoomsMu.Lock()
	defer c.SavedRoomsMu.Unlock()

	// Check if already in saved rooms
	exists := false
	for _, r := range c.SavedRooms {
		if r == roomName {
			exists = true
			break
		}
	}

	if !exists {
		c.SavedRooms = append(c.SavedRooms, roomName)

		// Limit saved rooms to MaxSavedRoomsSize
		if len(c.SavedRooms) > MaxSavedRoomsSize {
			c.SavedRooms = c.SavedRooms[len(c.SavedRooms)-MaxSavedRoomsSize:]
		}

		// Persist to server
		go c.persistSavedRooms()

		// Notify UI of rooms update
		if c.OnRoomsUpdate != nil {
			fyne.Do(c.OnRoomsUpdate)
		}
	}
}

func (c *APIClient) RemoveRoomFromCache(roomName string) {
	c.SavedRoomsMu.Lock()
	defer c.SavedRoomsMu.Unlock()

	for i, r := range c.SavedRooms {
		if r == roomName {
			c.SavedRooms = append(c.SavedRooms[:i], c.SavedRooms[i+1:]...)

			// Persist to server
			go c.persistSavedRooms()

			// Notify UI of rooms update
			if c.OnRoomsUpdate != nil {
				fyne.Do(c.OnRoomsUpdate)
			}
			break
		}
	}
}

func (c *APIClient) GetSavedRooms() []string {
	c.SavedRoomsMu.RLock()
	defer c.SavedRoomsMu.RUnlock()

	// Return a copy
	rooms := make([]string, len(c.SavedRooms))
	copy(rooms, c.SavedRooms)
	return rooms
}

func (c *APIClient) persistSavedRooms() {
	c.SavedRoomsMu.RLock()
	roomsCopy := make([]string, len(c.SavedRooms))
	copy(roomsCopy, c.SavedRooms)
	c.SavedRoomsMu.RUnlock()

	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()
	ctx = c.getAuthContext(ctx)

	// Call the server to update saved rooms
	_, err := c.GrpcClient.UpdateUser(ctx, &pb.UpdateUserRequest{
		User: &pb.User{
			Email: c.User.Email,
			Rooms: roomsCopy,
		},
	})
	if err != nil {
		fmt.Printf("Error persisting saved rooms: %v\n", err)
	}
}

func (c *APIClient) AddToLocalHistory(roomName string) {
	c.HistoryMu.Lock()
	defer c.HistoryMu.Unlock()

	// Check if room is already in history
	for _, r := range c.LocalHistory {
		if r == roomName {
			return // Already in history
		}
	}
	c.LocalHistory = append(c.LocalHistory, roomName)

	// Limit history to MaxHistorySize
	if len(c.LocalHistory) > MaxHistorySize {
		c.LocalHistory = c.LocalHistory[len(c.LocalHistory)-MaxHistorySize:]
	}

	// Notify UI of history update on the main thread
	if c.OnHistoryUpdate != nil {
		fyne.Do(c.OnHistoryUpdate)
	}
}

func (c *APIClient) GetLocalHistory() []string {
	c.HistoryMu.RLock()
	defer c.HistoryMu.RUnlock()

	// Return a copy
	history := make([]string, len(c.LocalHistory))
	copy(history, c.LocalHistory)
	return history
}

func (c *APIClient) LeaveRoom(roomName string) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if cancel, ok := c.Cancels[roomName]; ok {
		cancel()
	}
	delete(c.Cancels, roomName)
	delete(c.Streams, roomName)
}

func (c *APIClient) StartStream(roomName string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if _, ok := c.Streams[roomName]; ok {
		return nil
	}

	ctx, cancel := context.WithCancel(context.Background())
	ctx = c.getAuthContext(ctx)

	stream, err := c.GrpcClient.Stream(ctx)
	if err != nil {
		cancel()
		return err
	}

	handshake := &pb.ChatMessage{
		UserId: c.User.Id,
		RoomId: roomName,
		Type:   pb.ChatMessage_TEXT,
		Payload: &pb.ChatMessage_MessageContent{
			MessageContent: "",
		},
	}
	if err := stream.Send(handshake); err != nil {
		cancel()
		return err
	}

	c.Streams[roomName] = stream
	c.Cancels[roomName] = cancel

	go func(rName string, s pb.ChatService_StreamClient) {
		defer cancel()
		for {
			msg, err := s.Recv()
			if err == io.EOF {
				return
			}
			if err != nil {
				if ctx.Err() == context.Canceled {
					return
				}
				fmt.Printf("Stream Error [%s]: %v\n", rName, err)
				return
			}
			c.MsgChan <- msg
		}
	}(roomName, stream)

	return nil
}

func (c *APIClient) SendMessage(roomName, text string) error {
	c.mu.RLock()
	stream, ok := c.Streams[roomName]
	c.mu.RUnlock()

	if !ok {
		return fmt.Errorf("not connected to room %s", roomName)
	}

	enc, err := EncryptMessage(text)
	if err != nil {
		return err
	}

	msg := &pb.ChatMessage{
		UserId:    c.User.Id,
		Email:     c.User.Email,
		RoomId:    roomName,
		Timestamp: time.Now().Unix(),
		Type:      pb.ChatMessage_TEXT,
		Payload: &pb.ChatMessage_MessageContent{
			MessageContent: enc.Data,
		},
		Iv:       enc.IV,
		HotSauce: enc.KeyName,
	}

	return stream.Send(msg)
}

func (c *APIClient) UpdatePassword(email, oldPass, newPass string) error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()

	// If the client is already logged in, attach the authorization token
	if c.Token != "" {
		ctx = c.getAuthContext(ctx)
	}

	resp, err := c.GrpcClient.UpdatePassword(ctx, &pb.UpdatePasswordRequest{
		Email:       email,
		OldPassword: oldPass,
		NewPassword: newPass,
	})
	if err != nil {
		return err
	}

	if !resp.Success {
		return fmt.Errorf("password update failed: %s", resp.Message)
	}

	return nil
}

func (c *APIClient) SendFileControl(roomID, hash, name, action string) error {
	msg := &pb.ChatMessage{
		RoomId: roomID,
		UserId: c.User.Id,
		Email:  c.User.Email,
		Type:   pb.ChatMessage_FILE_CONTROL,
		Payload: &pb.ChatMessage_FileMeta{
			FileMeta: &pb.FileMetadata{
				FileHash: hash,
				FileName: name,
				Action:   action,
			},
		},
	}
	c.mu.RLock()
	stream := c.Streams[roomID]
	c.mu.RUnlock()
	if stream == nil {
		return fmt.Errorf("stream for room %s not found", roomID)
	}
	return stream.Send(msg)
}

func (c *APIClient) SendFileChunks(roomID string, data []byte) error {
	const chunkSize = 1024 * 1024 // 1MB
	totalSize := len(data)

	c.mu.RLock()
	stream := c.Streams[roomID]
	c.mu.RUnlock()

	for i := 0; i < totalSize; i += chunkSize {
		end := i + chunkSize
		if end > totalSize {
			end = totalSize
		}

		msg := &pb.ChatMessage{
			RoomId:    roomID,
			UserId:    c.User.Id,
			Email:     c.User.Email,
			Type:      pb.ChatMessage_FILE_CHUNK,
			Timestamp: time.Now().Unix(),
			Payload: &pb.ChatMessage_DataChunk{
				DataChunk: data[i:end],
			},
		}

		if err := stream.Send(msg); err != nil {
			return err
		}
	}
	return nil
}

func (c *APIClient) StartOfferReaper(timeout time.Duration) {
	go func() {
		ticker := time.NewTicker(1 * time.Minute)
		for range ticker.C {
			now := time.Now()
			c.ActiveOffers.Range(func(key, value interface{}) bool {
				offer := value.(PendingFile)
				if now.Sub(offer.Timestamp) > timeout {
					c.ActiveOffers.Delete(key)
				}
				return true
			})
		}
	}()
}

func (c *APIClient) SaveFileToDisk(path string, data []byte) error {
	return os.WriteFile(path, data, 0644)
}
