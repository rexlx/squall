package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"os"
	"sync"
	"time"

	pb "github.com/rexlx/squall/proto"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/metadata"
)

type PendingFile struct {
	Data      []byte
	FileName  string
	Timestamp time.Time
}

type APIClient struct {
	GrpcClient pb.ChatServiceClient
	Conn       *grpc.ClientConn

	// Map of RoomID -> Stream
	Streams map[string]pb.ChatService_StreamClient
	// Map of RoomID -> CancelFunc (to stop the receiving goroutine/context)
	Cancels map[string]context.CancelFunc
	mu      sync.RWMutex

	Token   string
	User    *pb.User
	MsgChan chan *pb.ChatMessage

	// Security: Tracks files we have offered for P2P transfer
	ActiveOffers sync.Map // Map[string]PendingFile (Key: FileHash)
}

var Client = &APIClient{
	MsgChan: make(chan *pb.ChatMessage, 100),
	Streams: make(map[string]pb.ChatService_StreamClient),
	Cancels: make(map[string]context.CancelFunc),
}

func LoadTLSConfig() (*tls.Config, error) {
	// Use the bundled resources generated by 'fyne bundle'
	// resourceClientCertPem and resourceClientKeyPem are defined in bundle.go
	cert, err := tls.X509KeyPair(resourceClientCertPem.Content(), resourceClientKeyPem.Content())
	if err != nil {
		return nil, err
	}

	cfh := &tls.Config{
		Certificates:       []tls.Certificate{cert},
		InsecureSkipVerify: true,
	}
	return cfh, nil
}

func InitClient() error {
	tlsConfig, err := LoadTLSConfig()
	if err != nil {
		return err
	}

	creds := credentials.NewTLS(tlsConfig)
	conn, err := grpc.Dial("neo.nullferatu.com:8085", grpc.WithTransportCredentials(creds))
	if err != nil {
		return err
	}

	Client.Conn = conn
	Client.GrpcClient = pb.NewChatServiceClient(conn)
	return nil
}

func (c *APIClient) Login(email, password string) error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()

	resp, err := c.GrpcClient.Login(ctx, &pb.LoginRequest{
		Email:    email,
		Password: password,
	})
	if err != nil {
		return err
	}

	if resp.Error {
		return fmt.Errorf("login failed: %s", resp.Message)
	}

	c.User = resp.User
	c.Token = resp.Token
	return nil
}

func (c *APIClient) getAuthContext(ctx context.Context) context.Context {
	md := metadata.Pairs("authorization", c.Token)
	return metadata.NewOutgoingContext(ctx, md)
}

func (c *APIClient) JoinRoom(roomName string) error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()
	ctx = c.getAuthContext(ctx)

	resp, err := c.GrpcClient.JoinRoom(ctx, &pb.JoinRoomRequest{
		Email:    c.User.Email,
		RoomName: roomName,
	})
	if err != nil {
		return err
	}

	if len(resp.History) > 0 {
		for _, msg := range resp.History {
			c.MsgChan <- msg
		}
	}

	c.AddRoomToCache(roomName)
	return c.StartStream(roomName)
}

func (c *APIClient) AddRoomToCache(roomName string) {
	exists := false
	for _, r := range c.User.Rooms {
		if r == roomName {
			exists = true
			break
		}
	}
	if !exists {
		c.User.Rooms = append(c.User.Rooms, roomName)
	}
}

func (c *APIClient) LeaveRoom(roomName string) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if cancel, ok := c.Cancels[roomName]; ok {
		cancel()
	}
	delete(c.Cancels, roomName)
	delete(c.Streams, roomName)
}

func (c *APIClient) StartStream(roomName string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if _, ok := c.Streams[roomName]; ok {
		return nil
	}

	ctx, cancel := context.WithCancel(context.Background())
	ctx = c.getAuthContext(ctx)

	stream, err := c.GrpcClient.Stream(ctx)
	if err != nil {
		cancel()
		return err
	}

	handshake := &pb.ChatMessage{
		UserId: c.User.Id,
		RoomId: roomName,
		Type:   pb.ChatMessage_TEXT,
		Payload: &pb.ChatMessage_MessageContent{
			MessageContent: "",
		},
	}
	if err := stream.Send(handshake); err != nil {
		cancel()
		return err
	}

	c.Streams[roomName] = stream
	c.Cancels[roomName] = cancel

	go func(rName string, s pb.ChatService_StreamClient) {
		defer cancel()
		for {
			msg, err := s.Recv()
			if err == io.EOF {
				return
			}
			if err != nil {
				if ctx.Err() == context.Canceled {
					return
				}
				fmt.Printf("Stream Error [%s]: %v\n", rName, err)
				return
			}
			c.MsgChan <- msg
		}
	}(roomName, stream)

	return nil
}

func (c *APIClient) SendMessage(roomName, text string) error {
	c.mu.RLock()
	stream, ok := c.Streams[roomName]
	c.mu.RUnlock()

	if !ok {
		return fmt.Errorf("not connected to room %s", roomName)
	}

	enc, err := EncryptMessage(text)
	if err != nil {
		return err
	}

	msg := &pb.ChatMessage{
		UserId:    c.User.Id,
		Email:     c.User.Email,
		RoomId:    roomName,
		Timestamp: time.Now().Unix(),
		Type:      pb.ChatMessage_TEXT,
		Payload: &pb.ChatMessage_MessageContent{
			MessageContent: enc.Data,
		},
		Iv:       enc.IV,
		HotSauce: enc.KeyName,
	}

	return stream.Send(msg)
}

func (c *APIClient) SendFileControl(roomID, hash, name, action string) error {
	msg := &pb.ChatMessage{
		RoomId: roomID,
		UserId: c.User.Id,
		Email:  c.User.Email,
		Type:   pb.ChatMessage_FILE_CONTROL,
		Payload: &pb.ChatMessage_FileMeta{
			FileMeta: &pb.FileMetadata{
				FileHash: hash,
				FileName: name,
				Action:   action,
			},
		},
	}
	c.mu.RLock()
	stream := c.Streams[roomID]
	c.mu.RUnlock()
	if stream == nil {
		return fmt.Errorf("stream for room %s not found", roomID)
	}
	return stream.Send(msg)
}

func (c *APIClient) SendFileChunks(roomID string, data []byte) error {
	const chunkSize = 1024 * 1024 // 1MB
	totalSize := len(data)

	c.mu.RLock()
	stream := c.Streams[roomID]
	c.mu.RUnlock()

	for i := 0; i < totalSize; i += chunkSize {
		end := i + chunkSize
		if end > totalSize {
			end = totalSize
		}

		msg := &pb.ChatMessage{
			RoomId:    roomID,
			UserId:    c.User.Id,
			Email:     c.User.Email,
			Type:      pb.ChatMessage_FILE_CHUNK,
			Timestamp: time.Now().Unix(),
			Payload: &pb.ChatMessage_DataChunk{
				DataChunk: data[i:end],
			},
		}

		if err := stream.Send(msg); err != nil {
			return err
		}
	}
	return nil
}

func (c *APIClient) StartOfferReaper(timeout time.Duration) {
	go func() {
		ticker := time.NewTicker(1 * time.Minute)
		for range ticker.C {
			now := time.Now()
			c.ActiveOffers.Range(func(key, value interface{}) bool {
				offer := value.(PendingFile)
				if now.Sub(offer.Timestamp) > timeout {
					c.ActiveOffers.Delete(key)
				}
				return true
			})
		}
	}()
}

func (c *APIClient) SaveFileToDisk(path string, data []byte) error {
	return os.WriteFile(path, data, 0644)
}
