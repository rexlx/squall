package main

import (
	"bytes"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"net/http"
	"os"

	"github.com/gorilla/websocket"
)

type APIClient struct {
	Token       string
	User        User
	CurrentRoom Room
	Conn        *websocket.Conn
	MsgChan     chan Message
	HttpClient  *http.Client
	WsDialer    *websocket.Dialer
}

// Initialize the client with TLS configuration
var Client = &APIClient{
	MsgChan: make(chan Message, 10),
}

func InitClient() error {
	tlsConfig, err := LoadTLSConfig()
	if err != nil {
		return fmt.Errorf("failed to load TLS config: %v", err)
	}

	// 1. Configure HTTP Client with TLS
	Client.HttpClient = &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: tlsConfig,
		},
	}

	// 2. Configure WebSocket Dialer with TLS
	Client.WsDialer = &websocket.Dialer{
		TLSClientConfig: tlsConfig,
	}

	return nil
}

// LoadTLSConfig reads the certificates and prepares the TLS configuration
func LoadTLSConfig() (*tls.Config, error) {
	// 1. Load the CA certificate (to trust the server)
	caCert, err := os.ReadFile("ca-cert.pem")
	if err != nil {
		return nil, err
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	// 2. Load Client Certificate and Key (for mutual TLS)
	// These were generated by your script as client-cert.pem and client-key.pem
	cert, err := tls.LoadX509KeyPair("client-cert.pem", "client-key.pem")
	if err != nil {
		return nil, err
	}

	return &tls.Config{
		RootCAs:      caCertPool,              // Trust the server's CA
		Certificates: []tls.Certificate{cert}, // Present this client cert to server
		// If you are testing on localhost and the cert assumes a different domain
		// you might need to uncomment the line below, but it is insecure:
		InsecureSkipVerify: true,
	}, nil
}

func (c *APIClient) Login(email, password string) error {
	reqBody, _ := json.Marshal(LoginRequest{Email: email, Password: password})

	// Use c.HttpClient instead of http.DefaultClient
	resp, err := c.HttpClient.Post(API_BASE+"/login", "application/json", bytes.NewBuffer(reqBody))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("login failed: status %d", resp.StatusCode)
	}

	var data User
	// Assume token handling logic matches your server response
	c.Token = "simulated_token"

	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return err
	}
	c.User = data
	return nil
}

func (c *APIClient) JoinRoom(roomName string) error {
	payload := map[string]interface{}{
		"email":   c.User.Email,
		"name":    roomName,
		"regular": true,
	}
	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest("POST", API_BASE+"/room/"+roomName, bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+c.Token)
	req.Header.Set("Content-Type", "application/json")

	// Use c.HttpClient
	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("failed to join room: %d", resp.StatusCode)
	}

	var room Room
	if err := json.NewDecoder(resp.Body).Decode(&room); err != nil {
		return err
	}
	c.CurrentRoom = room
	return nil
}

func (c *APIClient) SendMessage(text string) error {
	enc, err := EncryptMessage(text)
	if err != nil {
		return err
	}

	msg := Message{
		Email:    c.User.Email,
		UserID:   c.User.ID,
		RoomID:   c.CurrentRoom.ID,
		Message:  enc.Data,
		HotSauce: enc.KeyName,
		IV:       enc.IV,
	}

	body, _ := json.Marshal(msg)
	req, _ := http.NewRequest("POST", API_BASE+"/message", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+c.Token)
	req.Header.Set("Content-Type", "application/json")

	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return err
	}
	return resp.Body.Close()
}

func (c *APIClient) ConnectWS(roomID string) {
	if c.Conn != nil {
		c.Conn.Close()
	}

	url := fmt.Sprintf("%s/ws/%s/%s", WS_BASE, roomID, "temp_key_placeholder")

	// Use c.WsDialer which has the TLS config
	conn, _, err := c.WsDialer.Dial(url, nil)
	if err != nil {
		fmt.Println("WS Error:", err)
		return
	}
	c.Conn = conn

	go func() {
		defer conn.Close()
		for {
			var msg Message
			err := conn.ReadJSON(&msg)
			if err != nil {
				fmt.Println("WS Read Error:", err)
				return
			}
			c.MsgChan <- msg
		}
	}()
}
